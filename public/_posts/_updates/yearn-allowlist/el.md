---
title: "H Λίστα του Yearn"
image:
  src: ./image1.jpg
  width: 770
  height: 367
date: '2022-05-06'
author: Weaver
translator: Stathis
---

![](./image1.jpg?w=770&h=367)

## Επισκόπηση  

Για να γίνει ο ιστότοπος του Yearn ακόμη πιο ασφαλής, πρόσφατα προστέθηκε μια νέα λειτουργία, η επονομαζόμενη Allowlist. Στην ουσία, επιτρέπει σε όλες τις συναλλαγές που πραγματοποιούνται μέσω του ιστότοπου/SDK να επικυρώνονται βάσει ενός on-chain συμβολαίου που διατηρεί αρχείο όλων των έγκυρων calldata (δεδομένων κλήσης) που είναι δυνατόν να παράγει ο ιστότοπος.

Αυτό αποτρέπει τον ιστότοπο από το να είναι ευάλωτος σε διάφορες επιθέσεις τύπου man-in-the-middle όπου παρέχονται δεδομένα στον ιστότοπο, είτε μέσω του API του Zapper/0x είτε μέσω του ίδιου του ιστότοπου του Yearn. Για παράδειγμα, εάν το API του Yearn επιστρέφει μια λίστα με θησαυροφυλάκια με κακόβουλες διευθύνσεις, με σκοπό οι χρήστες να εγκρίνουν ένα από αυτά όταν προσπαθούν να καταθέσουν, η Allowlist θα μπλοκάρει τη συναλλαγή από το να πραγματοποιηθεί.

Καλούμε και άλλα πρωτόκολλα να αξιοποιήσουν τις δικές τους Allowlists για να ενισχύσουν την ασφάλειά τους. Οι οδηγίες για τη δημιουργία της δικής σας Allowlist περιγράφονται λεπτομερώς παρακάτω.

## Πώς λειτουργεί  

Ας πάρουμε ένα παράδειγμα επικύρωσης των calldata για μια συναλλαγή που εγκρίνει μια κατάθεση σε ένα θησαυροφυλάκιο.

Στο συμβόλαιο Allowlist υπάρχει ένας κατάλογος συνθηκών, οι οποίες είναι structs που επικυρώνονται βάσει αυτών.

Εδώ παρουσιάζεται αυτή για την έγκριση ενός token του θησαυροφυλακίου (σε μορφή JSON):

```
{
  "id"= "TOKEN_APPROVE_VAULT",
  "implementationId": "IMPLEMENTATION_YEARN_VAULTS",
  "methodName": "approve",
  "paramTypes": ["address", "uint256"],
  "requirements": [
    ["target", "isVaultUnderlyingToken"],
    ["param", "isVault", "0"]
  ]
}
```

- `id`: Το αναγνωριστικό της συνθήκης, επιτρέπει την ενημέρωση ή την αφαίρεση της συνθήκης από τον ιδιοκτήτη του πρωτοκόλλου.  

- `implementationId`: Το αναγνωριστικό του συμβολαίου υλοποίησης. Τα συμβόλαια υλοποίησης περιέχουν τη λογική για την επικύρωση της συνθήκης. Κάθε Allowlist μπορεί να έχει πολλαπλά συμβόλαια υλοποίησης για επικύρωση. Για παράδειγμα, στη λίστα Allowlist του Yearn, υπάρχει μια υλοποίηση για όλα τα θέματα που σχετίζονται με τα θησαυροφυλάκια και μια άλλη για το τμήμα labs του ιστότοπου, με πιο πειραματικά προϊόντα  

- `methodName`: Το όνομα της συνάρτησης που επιτρέπεται  

- `paramTypes`: Οι παράμετροι της συνάρτησης  

- `requirements`: Πληροφορίες σχετικά με τον τρόπο εκτέλεσης της επικύρωσης  

Μπορούν να υπάρχουν δύο τύποι απαιτήσεων: `target` και `param`.

- Εάν το πρώτο απαιτούμενο όρισμα είναι `target` τότε το επόμενο όρισμα θα είναι η συνάρτηση που θα πρέπει να κληθεί στην υλοποίηση για να επικυρώσει την διεύθυνση στόχο της συναλλαγής.  

- Εάν το πρώτο απαιτούμενο όρισμα είναι `param` τότε επίσης η συνάρτηση που πρέπει να χρησιμοποιηθεί για την επικύρωση είναι η επόμενη και το τελευταίο όρισμα είναι η θέση της παραμέτρου ώστε να μπορεί να εξαχθεί από τα calldata κατά την επικύρωση.  

Εδώ είναι η συναλλαγή, που εγκρίνει το Curve RocketPool Vault, την οποία θα επικυρώσουμε

- target:`0x447Ddd4960d9fdBF6af9a790560d0AF76795CB08`  
- calldata:`0x095ea7b30000000000000000000000005c0a86a32c129538d62c106eb8115a8b02358d570000000000000000000000000000000000c097ce7bc90715b34b9f1000000000`  

Υπάρχουν 3 βήματα για την επικύρωσή της:

1. Πρώτα ελέγχουμε τον [επιλογέα μεθόδου - method selector](https://github.com/yearn/eth-allowlist/blob/03f2a9ad5716abd0dbfc6d45885f5d6a04061edc/contracts/libraries/CalldataValidation.sol#L72). Από τη συνθήκη δημιουργούμε αυτό που περιμένουμε να είναι ο επιλογέας μεθόδου για μια συναλλαγή έγκρισης. Εφόσον έχουμε αποθηκεύσει το όνομα της συνάρτησης και τις παραμέτρους στη συνθήκη, μπορούμε να αναδημιουργήσουμε τη συνάρτηση και να πάρουμε `bytes4(keccak256(bytes(reconstructedMethodSignature)))`. Στη συνέχεια, μπορούμε να το συγκρίνουμε με τα πρώτα 4 bytes των calldata, για να διασφαλίσουμε ότι καλείται μια έγκυρη συνάρτηση από τον ιστότοπο. Η υπογραφή των 4 byte της `approve(address,uint256)` είναι `0x095ea7b3`, οπότε μπορούμε να δούμε ότι τα calldata είναι έγκυρα για αυτό.

2. Στη συνέχεια [επικυρώνουμε την διεύθυνση στόχο](https://github.com/yearn/eth-allowlist/blob/03f2a9ad5716abd0dbfc6d45885f5d6a04061edc/contracts/libraries/CalldataValidation.sol#L50). Για να το κάνουμε αυτό κάνουμε μια κλήση στο συμβόλαιο υλοποίησης της συνθήκης, χρησιμοποιώντας την παρεχόμενη επικύρωση, στην προκειμένη περίπτωση `isVaultUnderlyingToken`. Γνωρίζουμε πάντα ότι επικυρώνουμε μια διεύθυνση, οπότε μπορούμε να υποθέσουμε ότι η εν λόγω συνάρτηση έχει μια μόνο παράμετρο διεύθυνσης. Υποθέτουμε επίσης ότι αυτή η συνάρτηση επιστρέφει ένα `bool`. Εάν η τιμή που επιστρέφεται είναι false, τότε η συναλλαγή δεν είναι έγκυρη. Στο συμβόλαιο υλοποίησης υπάρχει μια συνάρτηση `isVaultUnderlyingToken` η οποία στη συνέχεια καλεί το μητρώο θησαυροφυλάκων του Yearn για να εκτελέσει την πραγματική επικύρωση.

3. Στη συνέχεια [επικυρώνουμε όλες τις συνθήκες παραμέτρων](https://github.com/yearn/eth-allowlist/blob/03f2a9ad5716abd0dbfc6d45885f5d6a04061edc/contracts/libraries/CalldataValidation.sol#L95), οι οποίες μπορεί να είναι περισσότερες από μία, ή καμία στην περίπτωση μιας συνάρτησης χωρίς ορίσματα. Σε αυτή την περίπτωση θέλουμε να ελέγξουμε ότι η παράμετρος στη θέση 0 ικανοποιεί τη συνάρτηση `isVault` στο συμβόλαιο υλοποίησης, με αυτόν τον τρόπο θα ξέρουμε ότι ο χρήστης καταθέτει σε έγκυρο θησαυροφυλάκιο. Και πάλι, το συμβόλαιο υλοποίησης χρησιμοποιεί το μητρώο θησαυροφυλακίων του Yearn για να ελέγξει αν η διεύθυνση που αποκωδικοποιείται από τα calldata είναι έγκυρο θησαυροφυλάκιο ή όχι.

Μια συναλλαγή που υποβάλλεται στη λίστα Allowlist επικυρώνεται σε σχέση με κάθε συνθήκη, αν κάποια από αυτές επιβεβαιώσει ότι η συναλλαγή είναι έγκυρη, τότε μπορούμε να είμαστε σίγουροι ότι η συναλλαγή που πρόκειται να υποβληθεί, όπως και αν δόθηκε στον χρήστη κατά την αλληλεπίδραση με τον ιστότοπο, δεν είναι κακόβουλη και ασφαλής προς εκτέλεση.

## Ποιος ελέγχει την Allowlist κάθε ιστότοπου;

Η Allowlist σχεδιάστηκε έτσι ώστε κάθε ιστότοπος να έχει μια δική του έκδοση, αλλά χρειαζόμαστε κάποιον τρόπο on-chain για να συνδέσουμε κάθε Allowlist με κάθε ιστότοπο. Για να το κάνουμε αυτό, χρησιμοποιούμε το ENS/DNSSEC για να επαληθεύσουμε τον ιδιοκτήτη κάθε domain - https://docs.ens.domains/dns-registrar-guide. Με αυτόν τον τρόπο γνωρίζουμε ότι ο έλεγχος της Allowlist συνδέεται με τον έλεγχο του domain, και εφόσον αυτό δεν παραβιάζεται, μπορεί να ανακτηθεί η σωστή Allowlist για έναν συγκεκριμένο ιστότοπο.

Η ασφάλεια μιας Allowlist εξαρτάται επίσης από τα συμβόλαια υλοποίησης. Αν αυτά ήταν εύκολα μεταβλητά ή αν υλοποιούνταν εσφαλμένα, τότε η ασφάλεια της Allowlist θα κινδύνευε. Είναι καλύτερο να γίνουν αυτά τα συμβόλαια αμετάβλητα, ή αν πρέπει να μπορούν να είναι επικαιροποιήσιμα, τότε θα ήταν προτιμότερη η ιδιοκτησία από το multisig του πρωτοκόλλου.

## Εγγραφή ως πρωτόκολλο

Για να δημιουργήσουν και να καταχωρήσουν τα πρωτόκολλα τη δική τους Allowlist μπορούν να κάνουν τα ακόλουθα βήματα:

- Ξεκινήστε την εγγραφή της Allowlist χρησιμοποιώντας το `registerProtocol` στο [Allowlist Registry συμβόλαιο](https://etherscan.io/address/0xb39c4EF6c7602f1888E3f3347f63F26c158c0336). Αυτό θα αναπτύξει μια νέα Allowlist για τον domain του πρωτοκόλλου. Σημείωση: ο λογαριασμός που ξεκινά την εγγραφή θα πρέπει να είναι εγγεγραμμένος ως ιδιοκτήτης του domain μέσω του ENS.
- Ανάπτυξη των προσαρμοσμένων συμβολαίων υλοποίησης, τα οποία μπορούν να χρησιμοποιηθούν για την επικύρωση στόχων/παραμέτρων
- Σύνδεση των συμβολαίων υλοποίησης με τη Allowlist χρησιμοποιώντας τη συνάρτηση `setImplementation`.
- Διευρεύνηση όλων των συναλλαγών που δημιουργούνται μέσω του ιστότοπου και δημιουργία των αντίστοιχων όρων. Ορίστε αυτές τις συνθήκες στη λίστα Allowlist χρησιμοποιώντας τη λειτουργία `addConditions`.

Ένα παράδειγμα ενός script ανάπτυξης μπορείτε να βρείτε [εδώ](https://github.com/yearn/yearn-allowlist/blob/main/scripts/chains/250/deploy.py)

## Μελλοντικές βελτιώσεις

Όπως περιγράφεται, η εν λόγω λειτουργία μειώνει τη χειραγώγηση των δεδομένων από τα οποία δημιουργούνται οι συναλλαγές που υποβάλλουν οι χρήστες, όπως δεδομένα από APIs. Ωστόσο, αν ο πηγαίος κώδικας του ιστότοπου παραβιαστεί ή αν εισαχθεί κακόβουλος κώδικας, τότε αυτοί οι έλεγχοι θα μπορούσαν απλώς να αγνοηθούν και να δημιουργηθούν κακόβουλες συναλλαγές που θα παρουσιαστούν στον χρήστη.

Για να αποφευχθεί αυτό, η Allowlist θα μπορούσε να ενσωματωθεί σε ένα πορτοφόλι (όπως το metamask), το οποίο θα επικύρωνε όλες τις συναλλαγές που πρόκειται να υποβληθούν με βάση την Allowlist που έχει ληφθεί για το όνομα domain από το οποίο προέρχεται η συναλλαγή. Αυτό θα εξαλείψει εντελώς τη χειραγώγηση του πηγαίου κώδικα του front-end σαν πιθανή επίθεση και θα αποτελούσε ανταγωνιστικό πλεονέκτημα για κάθε πορτοφόλι που το εφαρμόζει. Το Allowlist Registry μπορεί να χρησιμοποιηθεί για την επικύρωση οποιωνδήποτε calldata για οποιονδήποτε ιστότοπο με την ακόλουθη συνάρτηση:

```
/**
* @notice Determine whether or not a given target and calldata is valid
* @dev In order to be valid, target and calldata must pass the allowlist conditions tests
* @param targetAddress The target address of the method call
* @param data The raw calldata of the call
* @return isValid True if valid, false if not
*/
   
function validateCalldataByOrigin(
  string memory originName,
  address targetAddress,
  bytes calldata data
) public view returns (bool isValid) {
  address allowlistAddress = allowlistAddressByOriginName[originName];
  isValid = CalldataValidation.validateCalldataByAllowlist(
    allowlistAddress,
    targetAddress,
    data
  );
}
```

## Περαιτέρω ανάγνωση

**Eth-Allowlist**
https://github.com/yearn/eth-allowlist

**Παράδειγμα υλοποίησης της allowlist του Yearn**
https://github.com/yearn/yearn-allowlist

**Εγγραφή DNSENS**
https://docs.ens.domains/dns-registrar-guide

*Αυτό το άρθρο παραχωρήθηκε ανώνυμα από έναν προγραμματιστή του Yearn. Εγώ απλά έκανα copy pasta - xoxo weaver.*
